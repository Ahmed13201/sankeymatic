<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SankeyMATIC &alpha;</title>
<style>

body {
    font-family: sans-serif;
    font-size: small;
    background-color: #F8FDFF;
}

.errormessage {
    background-color: pink;
    color: #660000;
    border: 1px solid red;
    padding: 4px;
    margin: -1px;
}

.cautionmessage {
    background-color: #FFFFAA;
    color: #CC6600;
    border: 1px solid darkorange;
    padding: 4px;
    margin: -1px;
}

a.tooltip { border-bottom: 1px dotted; }

#entirety, #inputs, #messages {
  margin: 0px auto;
  display:table;
}

textarea#flows_in {
	border: 1px solid #006699;
    padding: 3px;
    margin: 4px;
	font-family: sans-serif;
	font-size: small;
}

#chart {
    height: 500px;
    width: 960px;
    border: 1px solid #447799;
    text-align: center;
    color: #006699;
    margin: 10px auto;
}

.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

/* GRAY links between nodes. fill should be nonexistent; stroke is all. */
.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
}

/* near-black links when hovering: */
.link:hover { stroke-opacity: .5; }

/* style for all of the svg label text: */
svg { font: 12px sans-serif; }

td {
    background-color: #BBDDEE;
    vertical-align: top;
    padding: 2px;
}

td#other_entry {
    background-color: #DDEEFF;
}

/* cellspacing 0 */
table { border-collapse: collapse; border-spacing: 0; }

th#title {
    padding: 0px 10px;
    background-color: #88BBCC;
    font-size: large;
}

td#flows_entry
{
    text-align: center;
    padding: 5px;
    vertical-align: middle;
}


</style>
</head>
<body>

<!-- script src="http://d3js.org/d3.v2.min.js?2.9.1"></script -->
<script src="d3.v2.js"></script>
<script src="sankey.js"></script>
<script>
function isNumeric(n) {
    // borrowed from jquery:
    /* "parseFloat NaNs numeric-cast false positives (null|true|false|"")
       ...but misinterprets leading-number strings, particularly hex literals ("0x...")
       subtraction forces infinities to NaN" */
    return n - parseFloat( n ) >= 0;
}

function escapeHtml(unsafe) {
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

function round_to_places(number_in, places) {
    return Math.round( number_in * Math.pow( 10, places ) )
        / Math.pow( 10, places );
}

function process_sankey() {
    "use strict";
    var flow_list, good_lines = [], bad_lines = [], line_ix, line_in,
        unique_nodes = {}, matched_params, amount_in;
    var messages_el = document.getElementById('messages_area');
    var raw_flows_var = document.getElementById('flows_in').value;
    var approved_nodes = [], approved_flows = [], approved_config = {};
    var max_decimal_places = 0;

    // Clear all messages:
    messages_el.innerHTML = '';

    // Put a message on the page using the specified class:
    function add_message(msg_class, msg_html) {
        messages_el.innerHTML = messages_el.innerHTML +
            '<p class="' + msg_class + '">' + msg_html + '</p>';
    }

    // Go through lots of validation with plenty of bailout points and
    // informative messages for the poor soul trying to do this.

    // Flows validation:
    // Is there anything there at all?
    if (raw_flows_var.length == 0) {
        add_message('errormessage',
            'Enter a list of flows (one per line). See TKTKTK for examples.');
        // No point in proceeding any further:
        return null;
    }

    // parse into structures: approved_nodes, approved_flows, approved_config
    flow_list = raw_flows_var.split("\n");

    // parse all the input lines, storing good ones vs bad ones:
    for ( line_ix = 0; line_ix < flow_list.length; ++line_ix ) {
        // Does this line match the basic format?
        line_in = flow_list[line_ix];
        matched_params = line_in.match( /^(.+)\[([\d\.\s\+\-]+)\](.+)$/ );
        if (matched_params !== null) {
            // The Amount looked like a number; is it really (after tossing out whitespace)?
            amount_in = matched_params[2].replace(/\s/g,'');
            if ( !isNumeric(amount_in) ) {
                bad_lines.push (
                    { 'value' : line_in,
                      'message' : 'The Amount is not a valid decimal number.' } );
            } else if (amount_in < 0) {
                // The Sankey library doesn't currently support negative numbers:
                bad_lines.push (
                    { 'value' : line_in,
                      'message' : 'An Amount cannot be negative.' } );
            } else {
                // All seems well, save it as good:
                good_lines.push(
                    { 'source' : matched_params[1].trim(),
                      'target' : matched_params[3].trim(),
                      'amount' : amount_in } );
                // We need the maximum precision of the inputs (# of characters
                // to the RIGHT of the decimal) for some error checking
                // operations later:
                max_decimal_places =
                    Math.max( max_decimal_places,
                        ( ( amount_in.split( /\./ ) )[1] || '' ).length );
            }
        } else if ( line_in !== '' ) {
            // There was input, but something made it not match the pattern:
            bad_lines.push(
                { 'value' : line_in,
                  'message' :
                    'The line is not in the format: Source [Amount] Target' }
            );
        }
        // else, the final case: a blank line. We just skip those silently, so
        // someone can separate their input lines with whitespace if desired.
    }

    // console.log(JSON.stringify(bad_lines));

    // Mention the bad lines in the message area:
    bad_lines.forEach(function(parse_error) {
        add_message('errormessage',
            '&quot;<b>' + escapeHtml(parse_error.value) + '</b>&quot;: ' +
             parse_error.message);
    });

    // save_node: Add a node to the unique list (if it's not there already):
    function save_node(nodename) {
        // Have we NOT seen this node before? Then add it:
        if ( !(nodename in unique_nodes) ) {
            // establish the hash, including which index # this node will use:
            unique_nodes[nodename] = {
                "from_sum": 0,   "to_sum": 0,
                "from_list": [], "to_list": [],
                "index": approved_nodes.length
            };
            // approved_nodes = the node list, formatted for the render routine:
            approved_nodes.push( { "name": nodename } );
        }
        // If we have seen a node, there's nothing else to do currently
        // (Eventually: look for any additional properties the user may have put on this line)
    }

    // Given good_lines, make the lists of nodes and flows
    good_lines.forEach( function(node) {
        // console.log(node.source)
        save_node(node.source);
        save_node(node.target);

        // Add the encoded flow to the list of approved flows:
        approved_flows.push({
            "source": unique_nodes[node.source].index,
            "target": unique_nodes[node.target].index,
            "value": node.amount
            }
        );
        // Save useful information for the flow cross-check:
        unique_nodes[node.source].from_sum += Number(node.amount);
        unique_nodes[node.source].from_list.push(node.amount);
        unique_nodes[node.target].to_sum += Number(node.amount);
        unique_nodes[node.target].to_list.push(node.amount);
    });

    // console.log(JSON.stringify(unique_nodes));

    // Flow cross-check: Test if the total INTO a node is equal to the amount
    // OUT OF it; warn the user if not:
    Object.keys(unique_nodes).forEach( function(nodename) {
        var this_node = unique_nodes[nodename], difference;
        // Skip any nodes with 0 as the From or To amount; those are the starting &
        // ending nodes for the whole graph:
        if ( this_node.from_sum > 0 && this_node.to_sum > 0) {
            difference = this_node.to_sum - this_node.from_sum;
            // Is the difference great enough to matter? (i.e. bigger than 1/10
            // the smallest unit used?)
            if ( Math.abs(difference) >=
                Math.pow( 10,-max_decimal_places - 1 ) ) {
                // Construct a hyper-informative error message about the
                // imbalance.
                // If we don't round the outputs to match the maximum precision
                // of the inputs, we get uselessly long repeated decimals:
                add_message( "cautionmessage",
                    "&quot;<b>" + escapeHtml(nodename) + "</b>&quot;: " +
                    "The amount <strong>in</strong> (" +
                    '<a class="tooltip" title="' +
                    this_node.to_list.join(' + ') + '">' +
                    round_to_places( this_node.to_sum, max_decimal_places ) +
                    "</a>) is different from the amount <strong>out</strong> (" +
                    '<a class="tooltip" title="' +
                    this_node.from_list.join(' + ') + '">' +
                    round_to_places( this_node.from_sum, max_decimal_places ) +
                    "</a>) by " +
                    round_to_places( difference, max_decimal_places ) + "." );
            }
        }
    });

    //approved_nodes.forEach( function(x) { console.log(JSON.stringify(x)); } );
    //approved_flows.forEach( function(x) { console.log(JSON.stringify(x)); } );

    // do the actual rendering:
    return render_sankey(approved_nodes, approved_flows, approved_config);
}


function render_sankey(nodes_in, flows_in, config_in) {
    "use strict";

    var canvas_width, canvas_height,
        dollars_format, colorlist, first_word, svg, sankey, flow, link, node,
        node_width = 15, node_padding = 10,
        total_width = 960, total_height = 500,
        margin_top = 6, margin_bottom = 6,
        margin_left = 6, margin_right = 6;

    // # set chart dimensions to match?
    //console.log('inside function');
    var the_clean_json = {
        "nodes": nodes_in,
        "links": flows_in
    };

    // Set the dimensions of the space:
    canvas_width = total_width - margin_left - margin_right;
    canvas_height = total_height - margin_top - margin_bottom;
    //console.log("width=",canvas_width);

    // set up: formatting function for numeric labels
    dollars_format = function (d) { return '$' + d3.format(",.0f")(d); };

    colorlist = d3.scale.category20(); // produces a list of 20 compatible colors to choose from

    // clear out all contents:
    document.getElementById('chart').innerHTML = '';

    // append the svg canvas to the page with the defined dimensions:
    svg = d3.select("#chart").append("svg")
        .attr("width", total_width)
        .attr("height", total_height)
        .append("g")
        .attr("transform", "translate(" + margin_left + "," + margin_top + ")");

    // create a sankey object & its properties.. node widths constant at 15 & padding 10
    sankey = d3.sankey()
        .nodeWidth(node_width)
        .nodePadding(node_padding)
        .size([canvas_width, canvas_height])
        .nodes(the_clean_json.nodes)
        .links(the_clean_json.links)
        .layout(64);

    // flow is a function returning coordinates and specs for each flow area
    flow = sankey.link();

    link = svg.append("g").selectAll(".link")
        .data(the_clean_json.links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", flow) // embed coordinates
        .style("stroke-width", function (d) { return Math.max(1, d.dy); }) // apply stroke-width
        .sort(function (a, b) { return b.dy - a.dy; }); // set the order of display?

    link.append("title") // Make tooltips for FLOWS
        .text(function (d) { return d.source.name + " → " + d.target.name + "\n" + dollars_format(d.value); });

    // define drag function for use in node definitions
    function dragmove(d) {
        // Calculate new position:
        d.x = Math.max(0, Math.min(canvas_width - d.dx, d3.event.x));
        d.y = Math.max(0, Math.min(canvas_height - d.dy, d3.event.y));
        d3.select(this).attr(
            "transform",
            "translate(" + d.x + "," + d.y + ")"
        );
        // re-render:
        sankey.relayout();
        // re-write new flow metadata?
        link.attr("d", flow);
    }

    // Set up NODE info, behaviors:
    node = svg.append("g").selectAll(".node")
        .data(the_clean_json.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; })
        .call(d3.behavior.drag()
            .origin(function (d) { return d; })
            .on("dragstart", function () { this.parentNode.appendChild(this); })
            .on("drag", dragmove)
            );

    // Construct actual rectangles for NODEs:
    node.append("rect")
        .attr("height", function (d) { return d.dy; })
        .attr("width", node_width)
        .style("fill", function (d) {
            // Use the first word of the label as the basis for finding an
            // already-used color or picking a new one (case sensitive):
            first_word = (/^\W*(\w+)/.exec(d.name))[1];
            d.color = colorlist(first_word);
            return d.color;
        })
        .style("stroke", function (d) { return d3.rgb(d.color).darker(2); })
        .append("title")    // Add tooltips for NODES
        .text(function (d) { return d.name + "\n" + dollars_format(d.value); });

    // Put in NODE labels
    node.append("text")
        // x,y = offsets relative to the node rectangle
        .attr("x", -6)
        .attr("y", function (d) { return d.dy / 2; })
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .attr("transform", null)
        .text(function (d) { return d.name; })
        // In the left half of the picture, place labels to the right of nodes:
        .filter(function (d) { return d.x < canvas_width / 2; })
        .attr("x", 6 + node_width)
        .attr("text-anchor", "start");
}


</script>

<div id="entirety">

<form onsubmit="process_sankey(); return false;">

<table id="inputs">
<tr>
    <th id="title" rowspan="3">SankeyMATIC &alpha;
    <p style="margin:0; font-weight: normal; font-size:normal; font-style: italic;">alpha</p>
    </th>

    <td id="flows_entry">
    <strong>Enter a <u>list of FLOWS</u></strong>, one per line<br />
    Format: <strong>Source [Amount] Target</strong>, separated by spaces<br />

    <textarea id="flows_in" rows="8" cols="50">Thing One [10] Holding Area
Holding Area [7] Thing Three
Holding Area [6] Thing 4
Thing 1.5 [5] Holding Area
Holding Area [5] Thing 5
Thing 6 [3] Holding Area
Thing 4 [4] Item 7
Thing 4 [2] Item 8
Thing 5 [5] New thing 8</textarea>
    </td>

    <td id="other_entry">
    <input type="checkbox" name="live_validation" id="live_validation">
    <label for="live_validation"><s>Preview as I edit</s></label><br />
    <button type="submit">Preview</button><br />
    <br />
    ...Units?<br />
    ... Show units on hover / always / never?<br />
    ... size<br />
    ... width of nodes<br />
    </td>
</tr>
</table>

<table id="messages">
<tr>
    <td id="messages_area" colspan="2"></td>
</tr>
</table>

</form>

<p id="chart"><small>Diagram will appear here</small></p>

</div>

</body></html>
